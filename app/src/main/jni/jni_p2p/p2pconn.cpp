/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class com_example_alwin_p2ptest_P2PConn */
#include <android/log.h>
#include <stdlib.h>
#include <stdio.h>
#include <pthread.h>
#include <unistd.h>
#include <sys/time.h>
#include <netinet/in.h>
#include "p2pfunc.hh"
#include "p2ptypes.hh"
#include "AVSyncApi.hh"
#include "HonH264Decoder.h"
#include "SPS.h"

using namespace cricket;


// implement
#define MAX_DATA_LEN  (512*1024)
// 文件内的全局变量
static JavaVM *            g_CachedJvm;
static jclass              g_JavaNativeClass;
static NetCallBack *       g_NCallBack;
//static hw_rtp_unpack_264   g_MediaInfo = {0};
static unsigned char *     g_pDirectBuf = 0;
static HonH264Decoder *    g_H264Decoder = 0;
static int                 g_bSpsPpsInit = 0;
static int                 g_iIpcCnt = 0;
static AVSyncer *          g_IPCRtpSync = 0;
static AVSyncer *          g_CallRtpSync = 0;

// just for debug
//FILE * g_fp;

//call back function, soft dec
static int MediaDataSrcCallbackForDec(unsigned char * pBuf, int size)
{
	int i;
	int decRet;
	int imgWidth;
	int imgHeight;
	int lineY;
	int lineU;
	int lineV;
	int cpWY;
	int cpWU;
	int cpWV;
	unsigned char * srcY;
	unsigned char * srcU;
	unsigned char * srcV;
	unsigned char * dest;
	struct timespec sys_time = {0,0};

	clock_gettime(CLOCK_MONOTONIC,&sys_time);
	//__android_log_print(ANDROID_LOG_WARN, "rtsp_client", "start time:%ld-%ld\n",
	//		sys_time.tv_sec, sys_time.tv_nsec/1000000);
	int sps_length = 0;
	long long time_stamp = 0;
	char buf[20] = {0};

	if(NULL == g_H264Decoder){
		__android_log_print(ANDROID_LOG_WARN, "p2p client", "Decoder is NULL!\n");
		return 0;
	}

	JNIEnv *jEnv;
	jmethodID cbMethodData, cbMethodDataCallV, cbMethodDataCallA;
	jmethodID cbMethodConn;
	g_CachedJvm->AttachCurrentThread(&(jEnv), NULL);
	cbMethodData = jEnv->GetStaticMethodID(g_JavaNativeClass, "yuv_callback_directbuf", "(II)V");
	if(NULL == cbMethodData)
	{
		__android_log_print(ANDROID_LOG_WARN, "p2p client", "can not find cb\n");
		return 0;
	}

	decRet = 0;
	if (0 == g_bSpsPpsInit)
	{
		if (size > 5 && (pBuf[4]&0x60) > 0 &&((pBuf[4]&0x1f) == 0x07))  //sps/pps
		{
			//first SPS data, call decoder init
			//start decode use ffmpeg
			g_bSpsPpsInit = 1;
			decRet = g_H264Decoder->decodeframe(pBuf, size);//decode usr ffmpeg
			__android_log_print(ANDROID_LOG_WARN, "rtsp_client", "dec ret=%d\n", decRet);
			//copy data, then nofity java activity
			imgWidth = g_H264Decoder->getWidth();
			imgHeight = g_H264Decoder->getHeight();
			//__android_log_print(ANDROID_LOG_WARN, "rtsp_client", "width=%d,height=%d\n", imgWidth, imgHeight);
			lineY = g_H264Decoder->getYLinesize();
			lineU = g_H264Decoder->getULinesize();
			lineV = g_H264Decoder->getVLinesize();
			cpWY = lineY < imgWidth ? lineY:imgWidth;
			cpWU = lineU < imgWidth/2 ? lineU:imgWidth/2;
			cpWV = lineV < imgWidth/2 ? lineV:imgWidth/2;
			srcY = g_H264Decoder->getYDataPtr();
			srcU = g_H264Decoder->getUDataPtr();
			srcV = g_H264Decoder->getVDataPtr();
			dest = g_pDirectBuf;// copy yuv data to direct buffer
			for(i = 0; i < imgHeight; i++){
				//copy Y
				memcpy(dest, srcY, cpWY);
				dest += cpWY;
				srcY += lineY;
			}
			for(i = 0; i < imgHeight/2; i++){
				//copy U
				memcpy(dest, srcU, cpWU);
				dest += cpWU;
				srcU += lineU;
			}
			for(i = 0; i < imgHeight/2; i++){
				//copy V
				memcpy(dest, srcV, cpWV);
				dest += cpWV;
				srcV += lineV;
			}
			//fwrite(g_MediaInfo.memory_buf, 1, g_MediaInfo.frame_len, g_fp); // just for debug
			jEnv->CallStaticVoidMethod(g_JavaNativeClass,
					cbMethodData, imgWidth, imgHeight);
		}
	}
	else //sps and decoder has been inited
	{
		decRet = g_H264Decoder->decodeframe(pBuf, size);
		__android_log_print(ANDROID_LOG_WARN, "rtsp_client", "dec ret=%d\n", decRet);
		int imgWidth = g_H264Decoder->getWidth();
		int imgHeight = g_H264Decoder->getHeight();
		//copy data, then nofity java activity
		imgWidth = g_H264Decoder->getWidth();
		imgHeight = g_H264Decoder->getHeight();
		//__android_log_print(ANDROID_LOG_WARN, "rtsp_client", "width=%d,height=%d\n", imgWidth, imgHeight);
		lineY = g_H264Decoder->getYLinesize();
		lineU = g_H264Decoder->getULinesize();
		lineV = g_H264Decoder->getVLinesize();
		cpWY = lineY < imgWidth ? lineY:imgWidth;
		cpWU = lineU < imgWidth/2 ? lineU:imgWidth/2;
		cpWV = lineV < imgWidth/2 ? lineV:imgWidth/2;
		srcY = g_H264Decoder->getYDataPtr();
		srcU = g_H264Decoder->getUDataPtr();
		srcV = g_H264Decoder->getVDataPtr();
		dest = g_pDirectBuf;// copy yuv data to direct buffer
		for(i = 0; i < imgHeight; i++){
			//copy Y
			memcpy(dest, srcY, cpWY);
			dest += cpWY;
			srcY += lineY;
		}
		for(i = 0; i < imgHeight/2; i++){
			//copy U
			memcpy(dest, srcU, cpWU);
			dest += cpWU;
			srcU += lineU;
		}
		for(i = 0; i < imgHeight/2; i++){
			//copy V
			memcpy(dest, srcV, cpWV);
			dest += cpWV;
			srcV += lineV;
		}
		jEnv->CallStaticVoidMethod(g_JavaNativeClass,
				cbMethodData, imgWidth, imgHeight);
	}
	g_CachedJvm->DetachCurrentThread();
	clock_gettime(CLOCK_MONOTONIC,&sys_time);
	//__android_log_print(ANDROID_LOG_WARN, "rtsp_client", "end time:%ld-%ld\n",
	//		sys_time.tv_sec, sys_time.tv_nsec/1000000);
	return 1;

}
// nalu util
static int get_sps_length(unsigned char* sps_buffer, int sps_buffer_len, int* sps_real_len)
{
    int i = 0;
    int start_code_num = 0;
    unsigned char start_code[4] = {0x00, 0x00, 0x00, 0x01};

    if (sps_buffer_len < 4)
    {
        return 0; //invalid input srteam
    }

    for (i = 0; i < (sps_buffer_len - 3); i++)
    {
        if (0 == memcmp(&sps_buffer[i], start_code, 4))
        {
            start_code_num++;
        }

        if (3 == start_code_num) //have found sps, pps, come to the third nal, we can break
        {
            break;
        }
    }

    if (3 == start_code_num)
    {
        *sps_real_len = i;
        return 1;
    }
    else
    {
        return 0;
    }
}
#if 0
static void HandleIPCVideo(unsigned char * data, int len) {
	if(0 == data || len < 12) {
		__android_log_print(ANDROID_LOG_WARN, "p2p ipc", "len=%d\n", len);
		return;
	}
	int marker = data[1] & 0x80;
	unpack_264(&g_MediaInfo, data + 12, len - 12);
	if(marker) {
		// decode by ffmpeg
		MediaDataSrcCallbackForDec(g_MediaInfo.memory_buf, g_MediaInfo.frame_len);
		//__android_log_print(ANDROID_LOG_WARN, "p2p ipc", "decode one frame, len=%d .\n", g_MediaInfo.frame_len);
		//fwrite(g_MediaInfo.memory_buf, 1, g_MediaInfo.frame_len, g_fp); // just for debug
		reset_rtp_unpack_264(&g_MediaInfo);
	}
}
static void HandleCallVideo(unsigned char * data, int len) {
	//__android_log_print(ANDROID_LOG_WARN, "p2p ipc", "handle call video.\n");
	if(0 == data || len < 12) {
        __android_log_print(ANDROID_LOG_WARN, "p2p ipc", "len=%d\n", len);
        return;
    }
    int marker = data[1] & 0x80;
    unpack_264(&g_MediaInfo, data + 12, len - 12);
    if(marker) {
        // decode by ffmpeg
        MediaDataSrcCallbackForDec(g_MediaInfo.memory_buf, g_MediaInfo.frame_len);
        __android_log_print(ANDROID_LOG_WARN, "p2p ipc", "decode one frame.\n");
        //fwrite(g_MediaInfo.memory_buf, 1, g_MediaInfo.frame_len, g_fp); // just for debug
        reset_rtp_unpack_264(&g_MediaInfo);
    }
}
static void HandleCallAudio(unsigned char * data, int len, unsigned char * uuid) {
	//__android_log_print(ANDROID_LOG_WARN, "p2p ipc", "handle call audio.\n");
	if(len <= 12){
		return;
	}
	JNIEnv *jEnv;
    jmethodID cbMethodDataCallA;
    g_CachedJvm->AttachCurrentThread(&(jEnv), NULL);
    cbMethodDataCallA = jEnv->GetStaticMethodID(g_JavaNativeClass, "dataCallBackCallA", "([BILjava/lang/String;)V");
    if(cbMethodDataCallA == NULL) {
        __android_log_print(ANDROID_LOG_WARN, "p2p client", "get call back A failed!\n");
        g_CachedJvm->DetachCurrentThread();
        return;
    }
    jbyteArray msgData = jEnv->NewByteArray(len - 12);
    jstring uuidString = jEnv->NewStringUTF((char *)uuid);
    jEnv->SetByteArrayRegion(msgData, 0, (jint)(len - 12), (const jbyte*)(data + 12));
    jEnv->CallStaticVoidMethod(g_JavaNativeClass, cbMethodDataCallA, msgData, len - 12, uuidString);
    jEnv->DeleteLocalRef(msgData);
    jEnv->DeleteLocalRef(uuidString);
    g_CachedJvm->DetachCurrentThread();
}
#endif
// call this after doing sync
static void HandleCall(unsigned char * pBuf, int size, int type, int timestamp, unsigned char * uuid, int uuidLen)
{
    //__android_log_print(ANDROID_LOG_WARN, "p2p client", "handle call data, type:%d\n", type);
    //回调之前会判断数据有效性，这里就不判断了。
    int ret, width, height, spsLen;
    SPS streamSps; //解析sps，不需要pps。
    JNIEnv *jEnv;
    jbyteArray csdInfo;
    jmethodID cbMethodDataCallA, cbMethodDataCallV, cbUpdateStreamInfo;
    g_CachedJvm->AttachCurrentThread(&(jEnv), NULL);
    cbMethodDataCallA = jEnv->GetStaticMethodID(g_JavaNativeClass, "dataCallBackCallA", "([BILjava/lang/String;)V");
    cbMethodDataCallV = jEnv->GetStaticMethodID(g_JavaNativeClass, "dataCallBackCallV", "([BILjava/lang/String;)V");
    cbUpdateStreamInfo = jEnv->GetStaticMethodID(g_JavaNativeClass, "updateCallVideoInfo", "([BIII)V");
    if(cbMethodDataCallA == NULL || cbMethodDataCallV == NULL || cbUpdateStreamInfo == NULL) {
        __android_log_print(ANDROID_LOG_WARN, "p2p client", "get call back failed!\n");
        g_CachedJvm->DetachCurrentThread();
        return;
    }
    jbyteArray msgData = jEnv->NewByteArray(size);
    jstring uuidString = jEnv->NewStringUTF((char *)uuid);
    jEnv->SetByteArrayRegion(msgData, 0, (jint)(size), (const jbyte*)(pBuf));
    if(type == 0) {
        // video
        //__android_log_print(ANDROID_LOG_WARN, "p2p client", "data[0]=%x, data[1]=%x, data[2]=%x, data[3]=%x, data[4]=%x\n",
        //                    pBuf[0], pBuf[1], pBuf[2], pBuf[3], pBuf[4]);
        if((pBuf[4] & 0x1f) == 0x7) { // sps
            ret = decode_seq_parameter_set(pBuf + 5, &streamSps);
            //__android_log_print(ANDROID_LOG_WARN, "p2p client", "ret=%x\n", ret);
            if(0 == ret) {
                if(1 == streamSps.frame_mbs_only_flag)
                {
                    width = streamSps.mb_width*16;
                    height = streamSps.mb_height*16;
                }
                else
                {
                    width = streamSps.mb_width*16;
                    height = streamSps.mb_height*32;
                }
                //__android_log_print(ANDROID_LOG_WARN, "p2p client", "width=%d, height=%d\n", width, height);
                if (1 == get_sps_length(pBuf, size, &spsLen)){
                    csdInfo = jEnv->NewByteArray(spsLen);
                    jEnv->SetByteArrayRegion(csdInfo, 0, (jint)spsLen, (const jbyte*)pBuf);
                    jEnv->CallStaticVoidMethod(g_JavaNativeClass, cbUpdateStreamInfo, csdInfo, spsLen, width, height);
                    jEnv->DeleteLocalRef(csdInfo);
                }
            }
        }
        // call back with nalu data
        jEnv->CallStaticVoidMethod(g_JavaNativeClass, cbMethodDataCallV, msgData, size, uuidString);
    } else {
        // audio
        jEnv->CallStaticVoidMethod(g_JavaNativeClass, cbMethodDataCallA, msgData, size, uuidString);
    }
    jEnv->DeleteLocalRef(msgData);
    jEnv->DeleteLocalRef(uuidString);
    g_CachedJvm->DetachCurrentThread();
}
//
static void HandleIPC(unsigned char * pBuf, int size, int type, int timestamp, unsigned char * uuid, int uuidLen)
{
    //__android_log_print(ANDROID_LOG_WARN, "p2p client", "handle ipc data, type:%d\n", type);
    if(type != 0) {
        // audio do not support currently
        return;
    }
    // video
    int ret, width, height, spsLen = 0;
    SPS streamSps; //解析sps，不需要pps。
    //回调之前会判断数据有效性，这里就不判断了。
    JNIEnv *jEnv;
    jmethodID cbMethodData, cbUpdateStreamInfo;
    jbyteArray csdInfo;
    g_CachedJvm->AttachCurrentThread(&(jEnv), NULL);
    cbMethodData = jEnv->GetStaticMethodID(g_JavaNativeClass, "dataCallBack", "([BILjava/lang/String;)V");
    cbUpdateStreamInfo = jEnv->GetStaticMethodID(g_JavaNativeClass, "updateIPCVideoInfo", "([BIII)V");
    if(cbMethodData == NULL || NULL == cbUpdateStreamInfo) {
        __android_log_print(ANDROID_LOG_WARN, "p2p client", "get ipc back failed!\n");
        g_CachedJvm->DetachCurrentThread();
        return;
    }
    jbyteArray msgData = jEnv->NewByteArray(size);
    jstring uuidString = jEnv->NewStringUTF((char *)uuid);
    jEnv->SetByteArrayRegion(msgData, 0, (jint)(size), (const jbyte*)(pBuf));
    //__android_log_print(ANDROID_LOG_WARN, "p2p client", "data[4]=%x\n", pBuf[4]);
    if((pBuf[4] & 0x1f) == 0x7) { // sps
        ret = decode_seq_parameter_set(pBuf + 5, &streamSps);
        //__android_log_print(ANDROID_LOG_WARN, "p2p client", "ret=%x\n", ret);
        if(0 == ret) {
            if(1 == streamSps.frame_mbs_only_flag)
            {
                width = streamSps.mb_width*16;
                height = streamSps.mb_height*16;
            }
            else
            {
                width = streamSps.mb_width*16;
                height = streamSps.mb_height*32;
            }
            //__android_log_print(ANDROID_LOG_WARN, "p2p client", "width=%d, height=%d\n", width, height);
            if (1 == get_sps_length(pBuf, size, &spsLen)){
                __android_log_print(ANDROID_LOG_WARN, "p2p client", "sps len=\n", spsLen);
                csdInfo = jEnv->NewByteArray(spsLen);
                jEnv->SetByteArrayRegion(csdInfo, 0, (jint)spsLen, (const jbyte*)pBuf);
                jEnv->CallStaticVoidMethod(g_JavaNativeClass, cbUpdateStreamInfo, csdInfo, spsLen, width, height);
                jEnv->DeleteLocalRef(csdInfo);
            }
        }
    }
    jEnv->CallStaticVoidMethod(g_JavaNativeClass, cbMethodData, msgData, size, uuidString);
    jEnv->DeleteLocalRef(msgData);
    jEnv->DeleteLocalRef(uuidString);
    g_CachedJvm->DetachCurrentThread();
}

void NetCallBack::HandleCmEvent(uint32 msgID, uint32 wParam, int32* pParam, void *srcAddr, void *user)
{
    //jint size = 0;
    Tp2pAddr *sAddr = 0;
    Tp2pResult *presult;
    unsigned char * msg;
    unsigned char uuid_str[POS_UUID_LEN * 2 + 1];
	const char hexmap[] = {'0', '1', '2', '3', '4', '5', '6', '7','8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};
    if(srcAddr == NULL)
    {
        //__android_log_print(ANDROID_LOG_WARN, "p2p client", "call back with null\n");
        return;
    }

    // attach thread
    /*JNIEnv *jEnv;
    jmethodID cbMethodData, cbMethodDataCallV, cbMethodDataCallA;
    jmethodID cbMethodConn;
    g_CachedJvm->AttachCurrentThread(&(jEnv), NULL);
    cbMethodData = jEnv->GetStaticMethodID(g_JavaNativeClass, "dataCallBack", "([BILjava/lang/String;)V");
    cbMethodDataCallV = jEnv->GetStaticMethodID(g_JavaNativeClass, "dataCallBackCallV", "([BILjava/lang/String;)V");
    cbMethodDataCallA = jEnv->GetStaticMethodID(g_JavaNativeClass, "dataCallBackCallA", "([BILjava/lang/String;)V");
    cbMethodConn = jEnv->GetStaticMethodID(g_JavaNativeClass, "connCallBack", "(II)V");
    if(NULL == cbMethodData || NULL == cbMethodConn || cbMethodDataCallV == NULL || cbMethodDataCallA == NULL) {
        __android_log_print(ANDROID_LOG_WARN, "p2p client", "get call back failed!\n");
        g_CachedJvm->DetachCurrentThread();
        return;
    }*/

    sAddr = (Tp2pAddr*)srcAddr;
    const char * uuid = (char *)(sAddr->uuid);
    for (int i = 0; i < POS_UUID_LEN; ++i) {
		uuid_str[2 * i]     = hexmap[(uuid[i] & 0xF0) >> 4];
		uuid_str[2 * i + 1] = hexmap[uuid[i] & 0x0F];
	}
	uuid_str[POS_UUID_LEN * 2] = '\0';
	//jstring uuidString = jEnv->NewStringUTF((char *)uuid_str);
	msg = (unsigned char *) pParam;
	//__android_log_print(ANDROID_LOG_WARN, "p2p client", "get call back msg=%s\n", msg);
	//jbyteArray msgData = jEnv->NewByteArray(wParam);
    switch(msgID)
    {
        case 0:
            // p2p lib should handle this data
            presult = (Tp2pResult*)pParam;
            if(presult->type == CM_RESULT_NAT)
            {
                //printf("HandleCmEvent:: NAT to %d is %d\n", sAddr->uuid, presult->status);
                __android_log_print(ANDROID_LOG_WARN, "p2p client",
                    "HandleCmEvent:: NAT to %s is %d\n", uuid_str, presult->status);
                /*jEnv->CallStaticVoidMethod(g_JavaNativeClass, cbMethodConn, 1,
                    (jint)(presult->status));*/
            }
            else if(presult->type == CM_RESULT_SERVER)
            {
                //printf("HandleCmEvent:: Server %d:%d status is %d\n", sAddr->ip, sAddr->port, presult->status);
                __android_log_print(ANDROID_LOG_WARN, "p2p client",
                    "HandleCmEvent:: Server %d:%d status is %d\n", sAddr->ip, sAddr->port, presult->status);
                    /*jEnv->CallStaticVoidMethod(g_JavaNativeClass, cbMethodConn, 2,
                                        (jint)(presult->status));*/
            }
            else if (presult->type == CM_RESULT_CONNECT)
            {
                //printf("HandleCmEvent:: Connect to %d is %d\n", sAddr->uuid, presult->status);
                __android_log_print(ANDROID_LOG_WARN, "p2p client",
                    "HandleCmEvent:: Connect to %s is %d\n", uuid_str, presult->status);
                    /*jEnv->CallStaticVoidMethod(g_JavaNativeClass, cbMethodConn, 3,
                                        (jint)(presult->status));*/
            }
            break;
        case 1:
        	/*jEnv->SetByteArrayRegion(msgData, 0, (jint)wParam, (const jbyte*)(msg));
				jEnv->CallStaticVoidMethod(g_JavaNativeClass, cbMethodData, msgData,
				size, uuidString);*///直接回调到java层
        	//HandleIPCVideo(msg, wParam);
            if(NULL != g_IPCRtpSync) {
                g_IPCRtpSync->putVideoData(msg, wParam, uuid_str, POS_UUID_LEN * 2);
            }
        	g_iIpcCnt ++;
        	if(g_iIpcCnt%10  == 0){
        		// send keep alive every 10 packets
        		P2P_sendto((int8*)"keepalive", 9, sAddr);
        		__android_log_print(ANDROID_LOG_WARN, "p2p client", "send keep alive");
        	}
        	break;
        case 2:
        	/*jEnv->SetByteArrayRegion(msgData, 0, (jint)wParam, (const jbyte*)(msg));
				jEnv->CallStaticVoidMethod(g_JavaNativeClass, cbMethodDataCallV, msgData,
				size, uuidString);*///直接回调到java层
        	//HandleCallVideo(msg, wParam);
            if(NULL != g_CallRtpSync) {
                g_CallRtpSync->putVideoData(msg, wParam, uuid_str, POS_UUID_LEN * 2);
            }
        	break;
        case 3:
        	/*jEnv->SetByteArrayRegion(msgData, 0, (jint)wParam, (const jbyte*)(msg));
				jEnv->CallStaticVoidMethod(g_JavaNativeClass, cbMethodDataCallA, msgData,
				size, uuidString);*///直接回调到java层
        	//HandleCallAudio(msg, wParam, uuid_str);
            if(NULL != g_CallRtpSync) {
                g_CallRtpSync->putAudioData(msg, wParam, uuid_str, POS_UUID_LEN * 2);
            }
        	break;
        default:
        	__android_log_print(ANDROID_LOG_WARN, "p2p client", "unkown p2p type! type=%d\n", msgID);
            break;
    }
    //jEnv->DeleteLocalRef(msgData);
    //g_CachedJvm->DetachCurrentThread();
}

int setRtpHeadPcm(unsigned char * data) {
	static unsigned short seq = 0;
	static unsigned long  stp = 0;
	static unsigned long  lastTime = 0;

	struct timespec sys_time = {0, 0};
	unsigned short curSeq;
	unsigned long  curTime;

	data[0] = 0x80;
	data[1] = 0x08;
	curSeq = htons(seq++);
	memcpy(data + 2, &curSeq, 2);
	clock_gettime(CLOCK_MONOTONIC, &sys_time);
	curTime = sys_time.tv_sec * 1000 + sys_time.tv_nsec/1000000;
	/*if(lastTime != 0){
		stp += (curTime - lastTime) * 8;// 8K
	}*/
	stp += 160;
	lastTime = curTime;
	curTime = htonl(stp);
	memcpy(data + 4, &curTime, 4);
	data[8] = 0x01;
	data[9] = 0x02;
	data[10] = 0x03;
	data[11] = 0x04;
}

#ifndef _Included_com_honeywell_cubebase_nativeapi_P2PConn
#define _Included_com_honeywell_cubebase_nativeapi_P2PConn
#ifdef __cplusplus
extern "C" {
#endif

/*
 * Class:     com_example_alwin_p2ptest_P2PConn
 * Method:    initConn
 * Signature: (Ljava/lang/String;I)I
 */
JNIEXPORT jstring JNICALL Java_com_honeywell_cubeapp_nativeapi_P2PConn_initConn
  (JNIEnv * pEnv, jclass jClass, jstring strPath, jobject pBuf)
{
    //jint ret = -1;
	int i;
	uint8 * ret = NULL;
    const char * filePath;
    unsigned char uuid_str[POS_UUID_LEN * 2 + 1];
    const char hexmap[] = {'0', '1', '2', '3', '4', '5', '6', '7','8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};
    // global ref
    pEnv->GetJavaVM(&(g_CachedJvm));
    jclass P2PConnClass = pEnv->FindClass("com/honeywell/cubeapp/nativeapi/P2PConn");
    if(NULL != P2PConnClass)
    {
        g_JavaNativeClass = reinterpret_cast<jclass>(pEnv->NewGlobalRef(P2PConnClass));
    }
    else
    {
        __android_log_print(ANDROID_LOG_WARN, "p2p client", "can not find class P2PConn\n");
        return NULL;
    }
    // p2p init
    g_NCallBack = new NetCallBack();
    filePath = pEnv->GetStringUTFChars(strPath, 0);
    ret = P2P_init(g_NCallBack, 0, (int8 *)filePath);
    __android_log_print(ANDROID_LOG_WARN, "p2p client", "P2P_init ret=%s\n", ret);
    pEnv->ReleaseStringUTFChars(strPath, filePath);
    if(ret == NULL) {
    	return NULL;
    }
    /*for(i = 0; i < POS_UUID_LEN; i++) { //固定16字节数值
    	sprintf(&(uuid_str[i * 2]), "%02X", ret[i]);
    }*/
    for (int i = 0; i < POS_UUID_LEN; ++i) {
    	uuid_str[2 * i]     = hexmap[(ret[i] & 0xF0) >> 4];
    	uuid_str[2 * i + 1] = hexmap[ret[i] & 0x0F];
    }
    uuid_str[POS_UUID_LEN * 2] = '\0';
    __android_log_print(ANDROID_LOG_WARN, "p2p client", "P2P_init uuid_str=%s\n", uuid_str);
    jstring retStr = pEnv->NewStringUTF((char*)uuid_str);

    // direct buffer, 全局引用通过调用 DeleteGlobalRef() 来显式撤消
    g_pDirectBuf = (unsigned char *)pEnv->GetDirectBufferAddress(pBuf);
    if(0 != g_H264Decoder) {
    	delete g_H264Decoder;
    	g_H264Decoder = 0;
    }
    g_H264Decoder = new HonH264Decoder();
    g_IPCRtpSync = new AVSyncer();
    g_IPCRtpSync->setCallBack((void *)HandleIPC);
    g_CallRtpSync = new AVSyncer();
    g_CallRtpSync->setCallBack((void *)HandleCall);

    /*__android_log_print(ANDROID_LOG_WARN, "p2p client", "before init_rtp_unpack_264\n");
    // rtp组帧
    init_rtp_unpack_264(&g_MediaInfo);
    __android_log_print(ANDROID_LOG_WARN, "p2p client", "before reset_rtp_unpack_264\n");
    reset_rtp_unpack_264(&g_MediaInfo);
    __android_log_print(ANDROID_LOG_WARN, "p2p client", "after reset_rtp_unpack_264\n");*/

	//g_fp = fopen("/sdcard/test.h264", "wb"); // just for debug

    return retStr;
}

/*
 * Class:     com_example_alwin_p2ptest_P2PConn
 * Method:    unInitConn
 * Signature: ()I
 */
JNIEXPORT jint JNICALL Java_com_honeywell_cubeapp_nativeapi_P2PConn_unInitConn
  (JNIEnv * pEnv, jclass jClass)
{
    P2P_uninit();
    delete g_NCallBack;
    pEnv->DeleteGlobalRef(g_JavaNativeClass);
    // direct buffer
    //pEnv->DeleteGlobalRef(g_pDirectBuf);
    g_pDirectBuf = 0;
    delete g_H264Decoder;
    delete g_CallRtpSync;
    delete g_IPCRtpSync;
    g_H264Decoder = 0;
    g_bSpsPpsInit = 0;
    // rtp组帧
    //release_rtp_unpack_264(&g_MediaInfo);

    //fflush(g_fp); // just for debug
	//fclose(g_fp); // just for debug
	//g_fp = NULL;
    return 0;
}

/*
 * Class:     com_example_alwin_p2ptest_P2PConn
 * Method:    setupConnById
 * Signature: (I)I
 */
JNIEXPORT jint JNICALL Java_com_honeywell_cubeapp_nativeapi_P2PConn_setupConnById
  (JNIEnv * pEnv, jclass jClass, jstring ssId)
{
	int i, k;
	const char * uuid;
    jint ret = -1;
    int strLen = 0;
    uint8 uuid_data[POS_UUID_LEN];
    uuid = pEnv->GetStringUTFChars(ssId, 0);
    strLen = strlen(uuid);
    if(strLen < 1) {
    	return -1;
    }
    /*if(strLen > POS_UUID_LEN * 2) {
    	strLen = POS_UUID_LEN * 2;
    }*/
    for(i = 0; i < POS_UUID_LEN; i++) {
    	sscanf(&uuid[i * 2], "%02X", &k);
    	uuid_data[i] = (uint8)k;
    }
    Tp2pAddr dstAddr;
    //dstAddr.uuid = ssId; // uuid
    memcpy(dstAddr.uuid, uuid_data, POS_UUID_LEN);
    dstAddr.type = 0; // use uuid
    ret = P2P_connect(&dstAddr);
    // TODO: 记录uuid，可以在p2p回调时过滤。

    pEnv->ReleaseStringUTFChars(ssId, uuid);

    return ret;
}
JNIEXPORT jint JNICALL Java_com_honeywell_cubeapp_nativeapi_P2PConn_setupConnByIp
  (JNIEnv * pEnv, jclass jClass, int ip)
{
    jint ret = -1;

    //__android_log_print(ANDROID_LOG_WARN, "p2p client", "ip=%d\n", ip);
    Tp2pAddr dstAddr;
    dstAddr.type = CM_ADDR_TYPE_SOCK;
	dstAddr.ip = ip;
	dstAddr.port = 3488;
    ret = P2P_connect(&dstAddr);

    return ret;
}

/*
 * Class:     com_example_alwin_p2ptest_P2PConn
 * Method:    disConnById
 * Signature: (I)I
 */
JNIEXPORT jint JNICALL Java_com_honeywell_cubeapp_nativeapi_P2PConn_disConnById
  (JNIEnv * pEnv, jclass, jstring ssId)
{
    jint ret = -1;
    const char * uuid;
    int strLen = 0;
    int i,k;
    uint8 uuid_data[POS_UUID_LEN];
	uuid = pEnv->GetStringUTFChars(ssId, 0);
	strLen = strlen(uuid);
	if(strLen < 1) {
		return -1;
	}
	for(i = 0; i < POS_UUID_LEN; i++) {
		sscanf(&uuid[i * 2], "%02X", &k);
		uuid_data[i] = (uint8)k;
	}
    Tp2pAddr dstAddr;
    dstAddr.type = 0; // use uuid
    //dstAddr.uuid = ssId;
    memcpy(dstAddr.uuid, uuid_data, POS_UUID_LEN);
    ret = P2P_disconnect(&dstAddr);

    pEnv->ReleaseStringUTFChars(ssId, uuid);

    return ret;
}

/*
 * Class:     com_example_alwin_p2ptest_P2PConn
 * Method:    sendDataById
 * Signature: ([BII)I
 */
JNIEXPORT jint JNICALL Java_com_honeywell_cubeapp_nativeapi_P2PConn_sendDataById
  (JNIEnv * pEnv, jclass jClass, jbyteArray sndData, jint dataLen, jstring ssId)
{
	jint ret = -1;
	unsigned char * dataArray;
	int i,k;
	uint8 uuid_data[POS_UUID_LEN];

	const char * uuid;
	int strLen = 0;
	uuid = pEnv->GetStringUTFChars(ssId, 0);
	strLen = strlen(uuid);
	if(strLen < 1) {
		return -1;
	}
	for(i = 0; i < POS_UUID_LEN; i++) {
		sscanf(&uuid[i * 2], "%02X", &k);
		uuid_data[i] = (uint8)k;
	}

	if(dataLen < 1 || dataLen > MAX_DATA_LEN) {
		__android_log_print(ANDROID_LOG_WARN, "p2p client", "data len=%d, uuid:%s\n", dataLen, uuid);
		return -1;
	}

	dataArray = new unsigned char[dataLen];
	pEnv->GetByteArrayRegion(sndData, 0, dataLen, (jbyte*)(dataArray));
	Tp2pAddr dstAddr;
	dstAddr.type = CM_ADDR_TYPE_UUID;
	//dstAddr.uuid = ssId;
	memcpy(dstAddr.uuid, uuid_data, POS_UUID_LEN);
	ret = P2P_sendto((int8*)dataArray, dataLen, &dstAddr);

	delete dataArray;
	pEnv->ReleaseStringUTFChars(ssId, uuid);

	return ret;
}
JNIEXPORT jint JNICALL Java_com_honeywell_cubeapp_nativeapi_P2PConn_sendDataByIp
  (JNIEnv * pEnv, jclass jClass, jbyteArray sndData, jint dataLen, int ip)
{
	jint ret = -1;
	unsigned char * dataArray;

	if(dataLen < 1 || dataLen > MAX_DATA_LEN) {
		__android_log_print(ANDROID_LOG_WARN, "p2p client", "data len=%d, int=%d\n", dataLen, ip);
		return -1;
	}

	dataArray = new unsigned char[dataLen];
	pEnv->GetByteArrayRegion(sndData, 0, dataLen, (jbyte*)(dataArray));
	/*const char * ipAdd = pEnv->GetStringUTFChars(ssIp, 0);
	__android_log_print(ANDROID_LOG_WARN, "p2p client", "ip addr = %s\n", ipAdd);*/
	Tp2pAddr dstAddr;
	//memset(&dstAddr, 0, sizeof(dstAddr));
	dstAddr.type = CM_ADDR_TYPE_SOCK;
	dstAddr.ip = ip;
	dstAddr.port = 3488;
	ret = P2P_sendto((int8*)dataArray, dataLen, &dstAddr);

	delete dataArray;

	return ret;
}
// 通话数据，视频
JNIEXPORT jint JNICALL Java_com_honeywell_cubeapp_nativeapi_P2PConn_sendCallDataVById
  (JNIEnv * pEnv, jclass jClass, jbyteArray sndData, jint dataLen, jstring ssId)
{
	jint ret = -1;
	unsigned char * dataArray;
	int i,k;
	uint8 uuid_data[POS_UUID_LEN];

	const char * uuid;
	int strLen = 0;
	uuid = pEnv->GetStringUTFChars(ssId, 0);
	strLen = strlen(uuid);
	if(strLen < 1) {
		return -1;
	}
	for(i = 0; i < POS_UUID_LEN; i++) {
		sscanf(&uuid[i * 2], "%02X", &k);
		uuid_data[i] = (uint8)k;
	}

	if(dataLen < 1 || dataLen > MAX_DATA_LEN) {
		__android_log_print(ANDROID_LOG_WARN, "p2p client", "data len=%d, uuid:%s\n", dataLen, uuid);
		return -1;
	}

	dataArray = new unsigned char[dataLen];
	pEnv->GetByteArrayRegion(sndData, 0, dataLen, (jbyte*)(dataArray));
	Tp2pAddr dstAddr;
	dstAddr.type = CM_ADDR_TYPE_UUID;
	//dstAddr.uuid = ssId;
	memcpy(dstAddr.uuid, uuid_data, POS_UUID_LEN);
	ret = P2P_sendto((int8*)dataArray, dataLen, &dstAddr, 2);
    // TODO: 记录uuid，可以在p2p回调时过滤。

	delete dataArray;
	pEnv->ReleaseStringUTFChars(ssId, uuid);

	return ret;
}
//通话数据，音频
JNIEXPORT jint JNICALL Java_com_honeywell_cubeapp_nativeapi_P2PConn_sendCallDataAById
  (JNIEnv * pEnv, jclass jClass, jbyteArray sndData, jint dataLen, jstring ssId)
{
	jint ret = -1;
	unsigned char * dataArray;
	int i,k;
	uint8 uuid_data[POS_UUID_LEN];

	const char * uuid;
	int strLen = 0;
	uuid = pEnv->GetStringUTFChars(ssId, 0);
	strLen = strlen(uuid);
	if(strLen < 1) {
		return -1;
	}
	for(i = 0; i < POS_UUID_LEN; i++) {
		sscanf(&uuid[i * 2], "%02X", &k);
		uuid_data[i] = (uint8)k;
	}

	if(dataLen < 1 || dataLen > MAX_DATA_LEN) {
		__android_log_print(ANDROID_LOG_WARN, "p2p client", "data len=%d, uuid:%s\n", dataLen, uuid);
		return -1;
	}

	dataArray = new unsigned char[dataLen + 12];

	setRtpHeadPcm(dataArray);
	pEnv->GetByteArrayRegion(sndData, 0, dataLen, (jbyte*)(dataArray + 12));
	Tp2pAddr dstAddr;
	dstAddr.type = CM_ADDR_TYPE_UUID;
	//dstAddr.uuid = ssId;
	memcpy(dstAddr.uuid, uuid_data, POS_UUID_LEN);
	ret = P2P_sendto((int8*)dataArray, dataLen, &dstAddr, 3);

	delete dataArray;
	pEnv->ReleaseStringUTFChars(ssId, uuid);

	return ret;
}

#ifdef __cplusplus
}
#endif
#endif
